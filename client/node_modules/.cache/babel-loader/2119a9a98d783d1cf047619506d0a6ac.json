{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar util = require('util');\n\nvar OAuth2Strategy = require('passport-oauth2');\n\nvar InternalOAuthError = require('passport-oauth2').InternalOAuthError;\n/**\n * `getHost` utility function\n *\n * Takes a two character region code and returns a Bnet host URL\n *\n *Examples:\n *\n *     getHost('eu');  // returns 'eu.battle.net'\n *\n * @param {String} region\n * @return {String}\n * @api protected\n */\n\n\nfunction getHost(region) {\n  if (region === 'cn') {\n    return 'www.battlenet.com.cn';\n  } else {\n    return region + '.battle.net';\n  }\n}\n/**\n * `Strategy` constructor.\n *\n * The Bnet authentication strategy authenticates requests by delegating to\n * Battle.net using the OAuth 2.0 protocol.\n *\n * Applications must supply a `verify` callback which accepts an `accessToken`,\n * `refreshToken` and service-specific `profile`, and then calls the `done`\n * callback supplying a `user`, which should be set to `false` if the\n * credentials are not valid.  If an exception occured, `err` should be set.\n *\n * Options:\n *   - `clientID`      your Bnet application's Client ID\n *   - `clientSecret`  your Bnet application's Client Secret\n *   - `callbackURL`   URL to which Bnet will redirect the user after granting authorization\n *   - `region`        region of battlenet\n *   - `scope`         array of permission scopes to request.\n *\n * Examples:\n *\n *     passport.use(new BnetStrategy({\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret',\n *         region: 'us',\n *         callbackURL: 'https://www.example.net/auth/bnet/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\n\n\nfunction Strategy(options, verify) {\n  options = options || {};\n  options.region = options.region || 'us';\n  options.authorizationURL = options.authorizationURL || 'https://' + getHost(options.region) + '/oauth/authorize';\n  options.tokenURL = options.tokenURL || 'https://' + getHost(options.region) + '/oauth/token';\n  options.scopeSeparator = options.scopeSeparator || ' ';\n  options.customHeaders = options.customHeaders || {};\n  OAuth2Strategy.call(this, options, verify);\n\n  if (!options.clientSecret) {\n    throw new TypeError('OAuth2Strategy requires a clientSecret option');\n  }\n\n  this.name = 'bnet';\n  this._profileUrl = options.userURL || 'https://' + getHost(options.region) + '/oauth/userinfo';\n\n  this._oauth2.useAuthorizationHeaderforGET(true);\n}\n/**\n * Inherit from `OAuth2Strategy`.\n */\n\n\nutil.inherits(Strategy, OAuth2Strategy);\n/**\n * Retrieve user profile from Bnet.\n *\n * This function constructs a normalized profile, with the following properties:\n *\n *   - `provider`         always set to `bnet`\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\n\nStrategy.prototype.userProfile = function (accessToken, done) {\n  this._oauth2.get(this._profileUrl, accessToken, function (err, body, res) {\n    var json;\n\n    if (err) {\n      return done(new InternalOAuthError('Failed to fetch the user id', err));\n    }\n\n    try {\n      json = JSON.parse(body);\n    } catch (ex) {\n      return done(new Error('Failed to parse the user id'));\n    }\n\n    var profile = json;\n    profile.provider = 'bnet';\n    profile.token = accessToken;\n    return done(null, profile);\n  });\n};\n/**\n * Expose `Strategy`.\n */\n\n\nmodule.exports = Strategy;","map":{"version":3,"sources":["/Users/jm-laptop/Documents/Portfolio/wowbislist/node_modules/passport-bnet/src/strategy.js"],"names":["util","require","OAuth2Strategy","InternalOAuthError","getHost","region","Strategy","options","verify","authorizationURL","tokenURL","scopeSeparator","customHeaders","call","clientSecret","TypeError","name","_profileUrl","userURL","_oauth2","useAuthorizationHeaderforGET","inherits","prototype","userProfile","accessToken","done","get","err","body","res","json","JSON","parse","ex","Error","profile","provider","token","module","exports"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\nvar util = require('util')\nvar OAuth2Strategy = require('passport-oauth2')\nvar InternalOAuthError = require('passport-oauth2').InternalOAuthError\n\n/**\n * `getHost` utility function\n *\n * Takes a two character region code and returns a Bnet host URL\n *\n *Examples:\n *\n *     getHost('eu');  // returns 'eu.battle.net'\n *\n * @param {String} region\n * @return {String}\n * @api protected\n */\nfunction getHost (region) {\n  if (region === 'cn') {\n    return 'www.battlenet.com.cn'\n  } else {\n    return region + '.battle.net'\n  }\n}\n\n/**\n * `Strategy` constructor.\n *\n * The Bnet authentication strategy authenticates requests by delegating to\n * Battle.net using the OAuth 2.0 protocol.\n *\n * Applications must supply a `verify` callback which accepts an `accessToken`,\n * `refreshToken` and service-specific `profile`, and then calls the `done`\n * callback supplying a `user`, which should be set to `false` if the\n * credentials are not valid.  If an exception occured, `err` should be set.\n *\n * Options:\n *   - `clientID`      your Bnet application's Client ID\n *   - `clientSecret`  your Bnet application's Client Secret\n *   - `callbackURL`   URL to which Bnet will redirect the user after granting authorization\n *   - `region`        region of battlenet\n *   - `scope`         array of permission scopes to request.\n *\n * Examples:\n *\n *     passport.use(new BnetStrategy({\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret',\n *         region: 'us',\n *         callbackURL: 'https://www.example.net/auth/bnet/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\nfunction Strategy (options, verify) {\n  options = options || {}\n  options.region = options.region || 'us'\n  options.authorizationURL = options.authorizationURL || 'https://' + getHost(options.region) + '/oauth/authorize'\n  options.tokenURL = options.tokenURL || 'https://' + getHost(options.region) + '/oauth/token'\n  options.scopeSeparator = options.scopeSeparator || ' '\n  options.customHeaders = options.customHeaders || {}\n\n  OAuth2Strategy.call(this, options, verify)\n  if (!options.clientSecret) {\n    throw new TypeError('OAuth2Strategy requires a clientSecret option')\n  }\n  this.name = 'bnet'\n  this._profileUrl = options.userURL || 'https://' + getHost(options.region) + '/oauth/userinfo'\n  this._oauth2.useAuthorizationHeaderforGET(true)\n}\n\n/**\n * Inherit from `OAuth2Strategy`.\n */\nutil.inherits(Strategy, OAuth2Strategy)\n\n/**\n * Retrieve user profile from Bnet.\n *\n * This function constructs a normalized profile, with the following properties:\n *\n *   - `provider`         always set to `bnet`\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\nStrategy.prototype.userProfile = function (accessToken, done) {\n  this._oauth2.get(this._profileUrl, accessToken, function (err, body, res) {\n    var json\n\n    if (err) {\n      return done(new InternalOAuthError('Failed to fetch the user id', err))\n    }\n\n    try {\n      json = JSON.parse(body)\n    } catch (ex) {\n      return done(new Error('Failed to parse the user id'))\n    }\n\n    var profile = json\n    profile.provider = 'bnet'\n    profile.token = accessToken\n\n    return done(null, profile)\n  })\n}\n\n/**\n * Expose `Strategy`.\n */\nmodule.exports = Strategy\n"]},"metadata":{},"sourceType":"script"}